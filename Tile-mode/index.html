<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>GBA圖形處理邏輯模擬(二) - Tile mode</title><meta name="description" content="compilation terminated."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="

cover

前文提到GBA的圖形繪製總共有兩種模式: Tile mode與Bitmap
mode，這兩種繪圖模式雖然使用相同的記憶體區段但是工作原理大不相同，因此我們可以將其視為兩個獨立的邏輯分別開發
我們緊接著就要來探討GBA tile mode的基礎知識

如何生成一幀畫面
背景與物件
先來看一個在Tile mode下繪製而成的遊戲畫面








Castlevania-Aria of sorrow, render
by NO$GBA



畫面中所有看的到的東西基本上是由兩種東西疊合而成: 1. 背景(background,
BG) 2. 物件(Object, OBJ)
他們之間的關係看起來會像是這樣:


bg_and_sprit.."><meta name="generator" content="Hexo 6.2.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="黃爸爸狗園" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">0rzgg's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">GBA圖形處理邏輯模擬(二) - Tile mode</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E4%B8%80%E5%B9%80%E7%95%AB%E9%9D%A2"><span class="toc-text">如何生成一幀畫面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E8%88%87%E7%89%A9%E4%BB%B6"><span class="toc-text">背景與物件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tile-map"><span class="toc-text">Tile &amp; map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mode-0-mode-1-mode-2"><span class="toc-text">Mode 0, Mode 1, Mode 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bg-control-register"><span class="toc-text">BG control register</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/GBA"><i class="tag post-item-tag">GBA</i></a><a href="/tags/emulator"><i class="tag post-item-tag">emulator</i></a><a href="/tags/graphics"><i class="tag post-item-tag">graphics</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">GBA圖形處理邏輯模擬(二) - Tile mode</h1><time class="has-text-grey" datetime="2022-08-03T17:38:07.000Z">2022-08-04</time><article class="mt-2 post-content"><figure>
<img src="https://i.imgur.com/SNkM4rS.jpg" alt="cover">
<figcaption aria-hidden="true">cover</figcaption>
</figure>
<p>前文提到GBA的圖形繪製總共有兩種模式: Tile mode與Bitmap
mode，這兩種繪圖模式雖然使用相同的記憶體區段但是工作原理大不相同，因此我們可以將其視為兩個獨立的邏輯分別開發</p>
<p>我們緊接著就要來探討GBA tile mode的基礎知識</p>
<span id="more"></span>
<h2 id="如何生成一幀畫面">如何生成一幀畫面</h2>
<h3 id="背景與物件">背景與物件</h3>
<p>先來看一個在Tile mode下繪製而成的遊戲畫面</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"><img src="https://i.imgur.com/7o8ccxI.png" alt="demo_frame"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><em>Castlevania-Aria of sorrow, render
by NO$GBA</em></td>
</tr>
</tbody>
</table>
<p>畫面中所有看的到的東西基本上是由兩種東西疊合而成: 1. 背景(background,
BG) 2. 物件(Object, OBJ)</p>
<p>他們之間的關係看起來會像是這樣:</p>
<figure>
<img src="https://i.imgur.com/SUNA8Vp.png" alt="bg_and_sprite">
<figcaption aria-hidden="true">bg_and_sprite</figcaption>
</figure>
<p>你會注意到背景與物件各有四層圖層，我們可以將剛剛的遊戲畫面分層來看</p>
<table>
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>BG_0</th>
<th>BG_1</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><img src="https://i.imgur.com/RtbYD5j.png%20=240x" alt="BG_0"></td>
<td><img src="https://i.imgur.com/L936ZTJ.png%20=240x" alt="BG_1"></td>
</tr>
<tr class="even">
<td>BG_2</td>
<td>BG_3</td>
</tr>
<tr class="odd">
<td><img src="https://i.imgur.com/XLf2E7m.png%20=240x" alt="BG_2"></td>
<td><img src="https://i.imgur.com/mC3BcUM.png%20=240x" alt="BG_3"></td>
</tr>
<tr class="even">
<td>OBJ(我疊合成一層了)</td>
<td></td>
</tr>
<tr class="odd">
<td><img src="https://i.imgur.com/Iv2fqsn.png%20=240x" alt="OBJ"></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="tile-map">Tile &amp; map</h2>
<p>我們現在知道在Tile
mode下，每一個畫面都是由背景跟物件所組成的了，那這些背景和物件又是如何被建構的呢?</p>
<p>要回答這個問題，我們必須從兩個方向來做分析:</p>
<ol type="1">
<li><p>用什麼東西組合 Tile
mode下所有的東西基本上都是由Tile所組合而成的，我們這裡所說的tile，是一塊一塊由8*8個pixel所組成的圖形資料，類似這種(仔細看，這是骷髏騎士的劍柄)
<img src="https://i.imgur.com/jKxBMLf.png" alt="tile_sample"></p>
<p>Tile的格式請參閱<a href="/Tile-format">GBA圖形處理邏輯模擬 - Tile
format</a></p></li>
<li><p>如何組合
另外一個需要釐清的問題是，我們該如何組合這些8*8的tile來產生我們想要的圖形，這就牽涉到我們現在是要繪製背景圖層還是物件，兩者的組合邏輯有些差異，詳細說明請參閱以下文章:</p>
<ul>
<li><a href="/Background-map">GBA圖形處理邏輯模擬 - Background
Map</a></li>
<li><a href="/oam">GBA圖形處理邏輯模擬 - Object Attribute
Memory(OAM)</a></li>
</ul></li>
</ol>
<h2 id="mode-0-mode-1-mode-2">Mode 0, Mode 1, Mode 2</h2>
<p>Tile mode實質意義上指的是Mode 0, 1,
2這三個模式，因為這三種模式都使用tile建構畫面的基礎，因此統稱為tile
mode</p>
<p>那這些mode有哪些特點呢，讓我們來仔細看一下這個表格:</p>
<figure>
<img src="https://i.imgur.com/MkrrczV.png" alt="mode_table">
<figcaption aria-hidden="true">mode_table</figcaption>
</figure>
<p>根據表格，我們可以得知以下數點不同之處:</p>
<ol type="1">
<li>是否有支援Affine(Rotation &amp; Scaling)功能
<ul>
<li>詳細請參考<a href="/Affine-background">GBA圖形處理邏輯模擬 - Affine
background</a></li>
</ul></li>
<li>最大可支援的Screen數量以及尺寸
<ul>
<li>詳細請參考<a href="/Background-map">GBA圖形處理邏輯模擬 - Background
Map</a></li>
</ul></li>
<li>最大可使用的Character(就是Tile)以及調色盤格式(palette)
<ul>
<li>詳細請參考<a href="/Tile-format">GBA圖形處理邏輯模擬 - Tile
format</a></li>
</ul></li>
</ol>
<h2 id="bg-control-register">BG control register</h2>
<p>前面有提到Tile mode下總共會有4層背景圖層，這四層圖層會受到當前的mode
number影響，決定是否能夠被使用</p>
<figure>
<img src="https://i.imgur.com/FjQLGRZ.png" alt="layer_info">
<figcaption aria-hidden="true">layer_info</figcaption>
</figure>
<ul>
<li>text與rotation/scaling是?
<ul>
<li>如表格所示，BG0與BG1這兩個圖層僅支援Text mode
<ul>
<li>換言之就是沒有旋轉跟縮放的mode</li>
</ul></li>
<li>而BG2與BG3則除了text mode之外，還可支援旋轉縮放
<ul>
<li>我會將rotation/scaling稱呼為affine</li>
</ul></li>
</ul></li>
</ul>
<p>另外，這四層背景繪製時也會有一些可控的參數，描述如下，你可以依照下面給出的連結查閱他們的詳細資訊</p>
<figure>
<img src="https://i.imgur.com/sGYRLSy.png" alt="bgcnt_info">
<figcaption aria-hidden="true">bgcnt_info</figcaption>
</figure>
<ul>
<li>對應四層圖層的register分別被mapping在(2 bytes each):
<ol type="1">
<li>BG0CNT(0x0400'0008)</li>
<li>BG1CNT(0x0400'000A)</li>
<li>BG2CNT(0x0400'000C)</li>
<li>BG3CNT(0x0400'000E)</li>
</ol></li>
<li>各欄位的詳細說明請參照:
<ul>
<li>Priority Specification
<ul>
<li><a href="/E2vEEDZsSSaBsZ4LtJGK8g">GBA圖形處理邏輯模擬 - Graphics
effect(WIP) #<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.448ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 640 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FC" d="M34 156Q34 270 120 356T309 442Q379 442 421 402T478 304Q484 275 485 237V208Q534 282 560 374Q564 388 566 390T582 393Q603 393 603 385Q603 376 594 346T558 261T497 161L486 147L487 123Q489 67 495 47T514 26Q528 28 540 37T557 60Q559 67 562 68T577 70Q597 70 597 62Q597 56 591 43Q579 19 556 5T512 -10H505Q438 -10 414 62L411 69L400 61Q390 53 370 41T325 18T267 -2T203 -11Q124 -11 79 39T34 156ZM208 26Q257 26 306 47T379 90L403 112Q401 255 396 290Q382 405 304 405Q235 405 183 332Q156 292 139 224T121 120Q121 71 146 49T208 26Z"></path></g></g></g></svg></mjx-container></span>
blending</a></li>
</ul></li>
<li>Character Base Block
<ul>
<li><a href="/Tile-format">GBA圖形處理邏輯模擬 - Tile format</a></li>
</ul></li>
<li>Mosaic
<ul>
<li><a href="/E2vEEDZsSSaBsZ4LtJGK8g">GBA圖形處理邏輯模擬 - Graphics
effect(WIP) #Mosaic</a></li>
</ul></li>
<li>Color Mode
<ul>
<li><a href="/Tile-format">GBA圖形處理邏輯模擬 - Tile format</a></li>
</ul></li>
<li>Screen Base Block
<ul>
<li><a href="/Background-map">GBA圖形處理邏輯模擬 - Background
Map</a></li>
</ul></li>
<li>Area Overflow Processing Flag
<ul>
<li>要注意這個flag對BG0與BG1無效</li>
<li>詳細請參考<a href="/Affine-background">GBA圖形處理邏輯模擬 - Affine
background</a></li>
</ul></li>
<li>Screen Size
<ul>
<li><a href="/Background-map">GBA圖形處理邏輯模擬 - Background
Map</a></li>
</ul></li>
</ul></li>
</ul>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/Tile-format/" title="GBA圖形處理邏輯模擬 - Tile format"><span class="has-text-weight-semibold">Next: GBA圖形處理邏輯模擬 - Tile format</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/GGORZ10227216"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> 0rzgg 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>