<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>boost::asio + boost::fiber之上下文切換機制</title><meta name="description" content="compilation terminated."><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="最近剛好在研究boost::asio，在研究官方範例的時候發現與fiber連動的code，感覺有點玄妙，來寫篇筆記

Autoecho

autoecho.cpp

這個範例基本上就是在同一個process內開一個tcp
server跟數個client，client會發送一個字串給server，然後server會把該字串echo回去
乍看之下蠻無聊的，但關鍵是這個程式只有一條thread在工作，所有的concurrency都是靠fiber在做
萬事起頭難，我們先來很快地審視過main()在幹嘛


int main( int argc, char* argv[]) {
    try {
//[asio_rr_setup
        std::shared_ptr&amp;lt; .."><meta name="generator" content="Hexo 6.2.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="黃爸爸狗園" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">0rzgg's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">boost::asio + boost::fiber之上下文切換機制</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/about">About</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#autoecho"><span class="toc-text">Autoecho</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async_something%E7%9A%84%E5%A5%A7%E7%A7%98"><span class="toc-text">async_something()的奧秘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E4%BC%B8%E9%96%B1%E8%AE%80"><span class="toc-text">延伸閱讀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B5%90%E8%AB%96"><span class="toc-text">結論</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/C++"><i class="tag post-item-tag">C++</i></a><a href="/tags/networking"><i class="tag post-item-tag">networking</i></a><a href="/tags/Boost"><i class="tag post-item-tag">Boost</i></a><a href="/tags/asynchronous_IO"><i class="tag post-item-tag">asynchronous_IO</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">boost::asio + boost::fiber之上下文切換機制</h1><time class="has-text-grey" datetime="2022-08-05T17:25:20.000Z">2022-08-06</time><article class="mt-2 post-content"><p>最近剛好在研究boost::asio，在研究官方範例的時候發現與fiber連動的code，感覺有點玄妙，來寫篇筆記</p>
<span id="more"></span>
<h2 id="autoecho">Autoecho</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.boost.org/doc/libs/1_79_0/libs/fiber/examples/asio/autoecho.cpp">autoecho.cpp</a>
<ul>
<li>這個範例基本上就是在同一個process內開一個tcp
server跟數個client，client會發送一個字串給server，然後server會把該字串echo回去</li>
<li>乍看之下蠻無聊的，但關鍵是<strong>這個程式只有一條thread在工作</strong>，所有的concurrency都是靠fiber在做</li>
<li>萬事起頭難，我們先來很快地審視過main()在幹嘛</li>
</ul></li>
</ul>
<pre class="cpp="><code>int main( int argc, char* argv[]) {
    try {
//[asio_rr_setup
        std::shared_ptr&lt; boost::asio::io_context &gt; io_ctx = std::make_shared&lt; boost::asio::io_context &gt;();
        boost::fibers::use_scheduling_algorithm&lt; boost::fibers::asio::round_robin &gt;( io_ctx);
//]
        print( "Thread ", thread_names.lookup(), ": started");
//[asio_rr_launch_fibers
        // server
        tcp::acceptor a( * io_ctx, tcp::endpoint( tcp::v4(), 9999) );
        boost::fibers::fiber( server, io_ctx, std::ref( a) ).detach();
        // client
        const unsigned iterations = 2;
        const unsigned clients = 3;
        boost::fibers::barrier b( clients);
        for ( unsigned i = 0; i &lt; clients; ++i) {
            boost::fibers::fiber(
                    client, io_ctx, std::ref( a), std::ref( b), iterations).detach();
        }
//]
//[asio_rr_run
        io_ctx-&gt;run();
//]
        print( tag(), ": io_context returned");
        print( "Thread ", thread_names.lookup(), ": stopping");
        std::cout &lt;&lt; "done." &lt;&lt; std::endl;
        return EXIT_SUCCESS;
    } catch ( std::exception const&amp; e) {
        print("Exception: ", e.what(), "\n");
    }
    return EXIT_FAILURE;
}</code></pre>
<ul>
<li>一開始先初始化io_context與設定fiber排成所用的algo為round
robin，這沒有太大的問題</li>
<li>再來是把server fiber跟client fiber都建立好，detach()出來</li>
<li>最後是io_ctx-&gt;run()讓目前主fiber把執行權讓出來，排程器就會抓剛剛排入的fiber出來跑</li>
</ul>
<h2 id="async_something的奧秘">async_something()的奧秘</h2>
<ul>
<li>我們可以從server()來切入問題</li>
</ul>
<pre class="cpp="><code>void server( std::shared_ptr&lt; boost::asio::io_context &gt; const&amp; io_ctx, tcp::acceptor &amp; a) {
    print( tag(), ": echo-server started");
    try {
        for (;;) {
            socket_ptr socket( new tcp::socket( * io_ctx) );
            boost::system::error_code ec;
            a.async_accept(
                    * socket,
                    boost::fibers::asio::yield[ec]);
            if ( ec) {
                throw boost::system::system_error( ec); //some other error
            } else {
                boost::fibers::fiber( session, socket).detach();
            }
        }
    } catch ( std::exception const&amp; ex) {
        print( tag(), ": caught exception : ", ex.what());
    }
    io_ctx-&gt;stop();
    print( tag(), ": echo-server stopped");
}</code></pre>
<ul>
<li>我們的server
fiber實體長這樣，但實際上只有做一個accept()動作，實際上處理連線的部份我們晚點會講</li>
<li>所以server()幹了啥?
<ul>
<li>使用我們在main裏頭準備好的acceptor
a去等待client的連線，async_accept()
<ul>
<li>喔齁!?</li>
</ul></li>
<li>來看一下async_accept()的signature，看看他是何方神聖</li>
</ul>
<pre class="cpp="><code>  template&lt;
    typename Protocol1,
    typename Executor1,
    typename AcceptToken = DEFAULT&gt;
  DEDUCED async_accept(
    basic_socket&lt; Protocol1, Executor1 &gt; &amp; peer,
    AcceptToken &amp;&amp; token = DEFAULT,
    typename constraint&lt; is_convertible&lt; Protocol, Protocol1 &gt;::value &gt;::type  = 0);</code></pre>
<ul>
<li>所以async_accept()要一個socket跟一個<strong>AcceptToken</strong>
<ul>
<li>socket沒問題，重點是那個AcceptToken到底是什麼咚咚?</li>
<li>簡單來說AcceptToken可以是一個callable，在未來的某一個時間點真的accept到東西的時候，接收來自kernel的error
code來做後續處理
<ul>
<li>就是async_accept()的callback拉</li>
</ul></li>
<li>但很顯然的，這個例子不是這樣</li>
</ul>
<pre class="cpp="><code>  a.async_accept(* socket, boost::fibers::asio::yield[ec]);</code></pre>
<ul>
<li>媽的貢丸，boost::fibers::asio::yield[ec]是啥玩意?
<ul>
<li>持續trace code，找到其定義</li>
</ul></li>
<li><pre class="cpp="><code>namespace boost {
namespace fibers {
namespace asio { 
    class yield_t {
    public:
        yield_t() = default;

        yield_t operator[]( boost::system::error_code &amp; ec) const                   {
            yield_t tmp;
            tmp.ec_ = &amp; ec;
            return tmp;
        }

        boost::system::error_code   *   ec_{ nullptr };
  };

thread_local yield_t yield{};
}}}</code></pre></li>
<li>好樣的，我們觸發了他的operator[]，具體只是把我們server()中的ec的addr綁到位於thread_local的yield上</li>
<li>然後作為<strong>AcceptToken</strong>傳遞給async_accept()，我的老天鵝，yield_t又沒有operator()，到底是怎麼樣變出callback的?</li>
<li>讓我們繼續往更深層跳......</li>
<li>我們一路step in，會看到一個關鍵位置</li>
</ul>
<pre class="cpp="><code>  typedef typename boost::asio::async_result&lt;
      typename decay&lt;CompletionToken&gt;::type,
      Signature&gt;::completion_handler_type completion_handler_type; 
    /*一些其他的code*/
    explicit async_completion(CompletionToken&amp; token)
          : completion_handler(static_cast&lt;typename conditional&lt;
            is_same&lt;CompletionToken, completion_handler_type&gt;::value,
            completion_handler_type&amp;, CompletionToken&amp;&amp;&gt;::type&gt;(token)),
            result(completion_handler)
    {
    }</code></pre>
<ul>
<li>哇，酷喔，因為我們給的AcceptToken是yield_t，導致上面的completion_handler_type被推導成<code>async_result&lt; boost::fibers::asio::yield_t, void(boost::system::error_code) &gt;</code></li>
<li>還真的有一個partial specialization長這樣</li>
<li><pre class="cpp="><code>    template&lt;&gt;
    class async_result&lt; boost::fibers::asio::yield_t, void(boost::system::error_code) &gt; :
      public boost::fibers::asio::detail::async_result_base {
      public:
          using return_type = void;
          using completion_handler_type = fibers::asio::detail::yield_handler&lt;void&gt;;

          explicit async_result( boost::fibers::asio::detail::yield_handler&lt; void &gt; &amp; h):
          boost::fibers::asio::detail::async_result_base{ h } {}
    };</code></pre>
<ul>
<li>你，看到了嗎.....?那個潛伏在陰暗角落，蠢蠢欲動的completion_handler_type</li>
</ul></li>
<li>講了那麼多，最後發現傳入yield_t之後，completion_handler最後會初始化成一個<strong>yield_handler</strong></li>
<li>這個咚咚可就厲害了，它可是有operator()的!!
<ul>
<li>但不要忘記，他還有個base class，一樣也有一個operator()</li>
<li>先來看一下yield_handler的operator()</li>
<li><pre class="cpp="><code>void operator()(boost::system::error_code const&amp; ec, T t) {
    BOOST_ASSERT_MSG( value_,
            "Must inject value ptr "
            "before caling yield_handler&lt;T&gt;::operator()()");

    * value_ = std::move( t);
    yield_handler_base::operator()(ec);
}</code></pre></li>
<li>我們可以看到value_(就是我們的socket)，會被assign
t，這個t就是當async_accept()完成之後會得到的socket</li>
<li>接線來就會繼續call yield_handler_base的operator()</li>
<li>所以我們現在知道，AcceptToken給yield_t，最後async_accept()完事之後會呼叫的callback來自這裡</li>
</ul></li>
<li>我們接著來看yield_handler_base的operator()做了啥?</li>
<li><pre class="cpp="><code>class yield_handler_base {
    public:
        yield_handler_base( yield_t const&amp; y) :
            ctx_{ boost::fibers::context::active() },
            yt_( y ) {}

        void operator()( boost::system::error_code const&amp; ec) {
            BOOST_ASSERT_MSG( ycomp_,
                "Must inject yield_completion* "
                "before calling yield_handler_base::operator()()");
            BOOST_ASSERT_MSG( yt_.ec_,
                "Must inject boost::system::error_code* "
                "before calling yield_handler_base::operator()()");

            yield_completion::lock_t lk{ ycomp_-&gt;mtx_ };
            yield_completion::state_t state = ycomp_-&gt;state_;

            ycomp_-&gt;state_ = yield_completion::complete;

            * yt_.ec_ = ec;
            lk.unlock();
            if ( yield_completion::waiting == state) {
                // wake the fiber
                fibers::context::active()-&gt;schedule( ctx_);
            }
        }

      boost::fibers::context      *   ctx_;
      yield_t                         yt_;
      yield_completion::ptr_t         ycomp_{};
};</code></pre></li>
<li>兩個重點
<ul>
<li><code>* yt_.ec_ = ec;</code>會把真正的error
code寫回我們給的yield_t</li>
<li><code>yield_completion::waiting == state</code>如果我們的server
fiber在async_accept()之後沒有馬上就accept到連線(正常來說都是這樣)，那麼這個state就會是waiting，我們此時就會把server
fiber的context排進排程裏頭，讓他盡快被跑起來</li>
</ul></li>
<li>跑起來之後就會把已經accept的socket交遊session fiber去執行工作</li>
</ul></li>
<li>但還有一個問題，我們在呼叫async_accept()之後，在我們正式accept到連線之前的這段時間內，執行權在誰手上
<ul>
<li>async_開頭的function都是non-blocking的，所以不會卡在原地</li>
<li>但看起來也不像是回到server fiber......</li>
<li>我們可以在往下看，我們的async_accept()事實上背後接著一個async_initiate()，這個東西內部有一個玄機</li>
<li><pre class="cpp="><code>template &lt;typename CompletionToken,
      BOOST_ASIO_COMPLETION_SIGNATURE Signature,
      typename Initiation, typename... Args&gt;
  inline typename enable_if&lt;
      !detail::async_result_has_initiate_memfn&lt;CompletionToken, Signature&gt;::value,
      BOOST_ASIO_INITFN_RESULT_TYPE(CompletionToken, Signature)&gt;::type
  async_initiate(BOOST_ASIO_MOVE_ARG(Initiation) initiation,
      BOOST_ASIO_NONDEDUCED_MOVE_ARG(CompletionToken) token,
      BOOST_ASIO_MOVE_ARG(Args)... args)
  {
    async_completion&lt;CompletionToken, Signature&gt; completion(token);

    BOOST_ASIO_MOVE_CAST(Initiation)(initiation)(
        BOOST_ASIO_MOVE_CAST(BOOST_ASIO_HANDLER_TYPE(CompletionToken,
          Signature))(completion.completion_handler),
        BOOST_ASIO_MOVE_CAST(Args)(args)...);

    return completion.result.get();
  }</code></pre></li>
<li>最後的那個completion.result.get()是關鍵，我們一個step進去看一看</li>
<li><pre class="cpp="><code>void get() {
     ycomp_-&gt;wait();
     if ( ec_) {
         throw_exception( boost::system::system_error{ ec_ } );
     }
}

/*再來直接看ycomp-&gt;wait()*/
void wait() {
     lock_t lk{ mtx_ };
     if ( complete != state_) {
         state_ = waiting;
         fibers::context::active()-&gt;suspend( lk); // !!
     }
}</code></pre></li>
<li>不看不知道，一看不得了，上面這段code說了啥?
<ul>
<li>假設我們呼叫get()的時候，ycomp的state不是complete(換言之，callback還沒有被跑過)，那基本上進去wait()就會觸發fibers::context::active()-&gt;suspend()</li>
<li>這個動作相當於是直接yield控制權，換言之，我們的async_accept()在呼叫後如果沒有馬上accept到連線的話，就會<strong>把控制權yield出來給其他fiber!!</strong></li>
</ul></li>
</ul></li>
<li>一旦async_accept()讓出執行權後，在他完成之前，就會有其他的fiber被拉起來跑(client
or session)，而當這兩個fiber各自也執行async
action的時候，就會如同上面async_accept()一樣讓出執行權
<ul>
<li>如此我們就能只靠一條thread達到concurrency了</li>
</ul></li>
</ul></li>
</ul>
<h2 id="延伸閱讀">延伸閱讀</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.boost.org/doc/libs/1_79_0/libs/fiber/doc/html/fiber/callbacks/then_there_s____boost_asio__.html">Then
There’s Boost.Asio</a></li>
<li><a target="_blank" rel="noopener" href="https://www.boost.org/doc/libs/1_79_0/doc/html/boost_asio/overview.html">Boost.Asio
overview</a></li>
<li><a target="_blank" rel="noopener" href="https://www.boost.org/doc/libs/1_79_0/libs/fiber/doc/html/index.html">Boost.fiber</a></li>
<li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-tw/%E6%84%9B%E9%BA%97%E7%B5%B2%E8%88%87%E9%AE%91%E4%BC%AF">愛麗絲與鮑伯</a></li>
</ul>
<h2 id="結論">結論</h2>
<p>想不到吧，Alice居然就是Bob!</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/Tile-mode/" title="GBA圖形處理邏輯模擬(二) - Tile mode"><span class="has-text-weight-semibold">Next: GBA圖形處理邏輯模擬(二) - Tile mode</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/GGORZ10227216"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> 0rzgg 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>