<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>GBA圖形處理邏輯模擬 (一)</title>
      <link href="/2022/07/22/GBA%E5%9C%96%E5%BD%A2%E8%99%95%E7%90%86%E9%82%8F%E8%BC%AF%E6%A8%A1%E6%93%AC-%E4%B8%80/"/>
      <url>/2022/07/22/GBA%E5%9C%96%E5%BD%A2%E8%99%95%E7%90%86%E9%82%8F%E8%BC%AF%E6%A8%A1%E6%93%AC-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/SNkM4rS.jpg" alt="cover"></p><p>GBA模擬器的開發之路，如果說CPU部分是思考&quot;我到底該怎麼做才對&quot;，那圖形的部分就會是&quot;我到底要怎麼做才會<em><strong>快</strong></em>&quot;</p><p>本系列文將會把重點聚焦在如何正確的實作一個GBA的圖形系統模擬函式庫，並提出一些手法來提升模擬的效率</p><span id="more"></span><h2 id="GBA圖形系統規格">GBA圖形系統規格<a class="anchor" href="#GBA圖形系統規格">·</a></h2><p>相較於近代的主機都普遍配有GPU來負責圖形渲染工作，GBA也有一塊獨立於CPU的處理邏輯負責圖形工作，也就是PPU(Pixel Processing Unit)</p><p>我們可以先來看一下PPU主要提供那些圖形處理功能:</p><ol><li>輸出畫面為240*160 pixels</li><li>色彩格式為RGB555</li><li>具有以下兩種渲染模式:<ul><li>Tile based: 基於利用尺寸為8*8的tile組合畫面，具有渲染速度快，還可以利用硬體仿射變換功能</li><li>Bitmap based: 直接由CPU將圖形資料以Pixel為單位寫入VRAM，自由度較高但效率差，須妥善利用DMA來實作</li></ul></li><li>最大支援128個Sprites於螢幕上顯示</li><li>支援數種圖形特效:<ul><li>Rotation/Scaling</li><li>alpha blending</li><li>fade-in/out</li><li>mosaic</li><li>window</li></ul></li></ol><h2 id="記憶體區段">記憶體區段<a class="anchor" href="#記憶體區段">·</a></h2><p>PPU的工作記憶體位於0x0500’0000~0x07ff’ffff，不同的段落具有不同的用途，描述如下:</p><p><img src="https://i.imgur.com/X7AeN95.png" alt="memory map"></p><ol><li><p>Palette memory: 0x0500’0000 ~ 0x0500’03ff</p><ul><li>功用為調色盤，一分為二，前半段為背景專用，後半段為OBJ使用</li><li>各具有256色，皆為RGB555格式</li><li>Bus為16 bit</li></ul></li><li><p>Video RAM(VRAM): 0x0600’0000 ~ 0x0601’7fff</p><ul><li>圖形系統的主記憶體，內容會根據繪圖模式有所不同，後面會詳述</li><li>Bus為16 bit</li></ul></li><li><p>OBJ Attributes(OAM): 0x0700’0000 ~ 0x0700’03ff</p><ul><li>用於描述各Sprite的屬性，以及Sprite在作仿射變換時所使用的矩陣內容</li><li>Bus為<strong>32 bit</strong></li></ul></li></ol><div class="warning"><p>聰明的小吉們應該有注意到一件事，我們在上面提到的address為0x0500’0000~0x07ff’ffff</p><p>但是下面再說明功能的時候，描述的範圍只有一部分，那剩下沒有涵蓋到(途中的黑色部分)的部分到底有沒有用???</p><p>這裡就必須要提及GBA系統的<a href="https://www.problemkaputt.de/gbatek.htm#gbaunpredictablethings">Undefined behavior</a>，其中的Memory mirror章節有提到GBA硬體的Bus在面對這些奇怪的R/W時會有那些行為</p><p>具體模擬的細節我會在MMU相關的文章內作說明</p></div><h2 id="開發環境">開發環境<a class="anchor" href="#開發環境">·</a></h2><p>我們的目標是要設計一個負責繪製GBA遊戲畫面的library，而非完全地將邏輯內嵌至模擬器主程式內，所以為了讓我們可以在沒有模擬除了PPU以外的功能的狀態下也能夠對PPU進行debug，我們勢必要開發一個前端，去調用PPU library所開出的介面來產生畫面</p><p>重點來了，阿你就沒有模擬整個系統，PPU怎麼會知道要繪製什麼東西???</p><p><img src="https://i.imgur.com/7AER30I.png" alt="pic"></p><p>而問題的答案也很簡單，找另外一個模擬器，直接去dump他的memory再寫進我們的PPU memory即可</p><p>有一個除錯器<a href="https://problemkaputt.de/gba.htm">NO$GBA</a>可以幫我們做到這件事情，我們在後續的開發流程也會持續的使用這個工具來協助我們釐清問題</p><h2 id="模擬流程">模擬流程<a class="anchor" href="#模擬流程">·</a></h2><p>上面的說明中我有特別提到PPU在GBA系統中扮演的角色類似於我們現代電腦系統的GPU，但是其工作原理其實與GPU差異很大</p><p>現在的GPU基本上擅長一次處理大量的頂點或貼圖資料，但GBA的繪製流程是以scanline為單位，一條一條畫，同時繪圖狀態會根據H-Blank與V-Blank作變化</p><p>因此，我們並不會直接就利用GPU來繪製我們模擬器的遊戲畫面，而是先行使用CPU在main memory上產生出pixel format為RGB555的frame buffer後，緊接著一次做完整個畫面的RGB555 to RGBA8888的轉換，最後一步才是透過ImGUI把buffer的內容轉成texture，交由GPU渲染。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GBA </tag>
            
            <tag> emulator </tag>
            
            <tag> graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GBA的軟體中斷與其相對應的處理</title>
      <link href="/2022/07/19/hardirq/"/>
      <url>/2022/07/19/hardirq/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/t0NzpK9.jpg" alt="cover"></p><p>GBA所使用的CPU ARM7TDMI要觸發中斷基本上有硬體中斷與軟體中斷兩種手段，兩種中斷的運作機制部份相似但在關鍵部份還是有所差異，若要正確模擬GBA的中斷就必須要將這兩種中斷的運作機制都搞清楚才行</p><p>換句話說，關於GBA的中斷沒有打模糊仗的空間，該讀的Spec就是要讀，該想的問題就是要想</p><p>本文會先就軟體中斷的部份作解說，硬體中斷會在另外一篇文章作描述</p><span id="more"></span><h2 id="軟體中斷-SWI">軟體中斷(SWI)<a class="anchor" href="#軟體中斷-SWI">·</a></h2><p><img src="https://i.imgur.com/E38ETY0.png" alt="">軟體中斷，顧名思義就是透過軟體觸發的中斷，更精確的說法是透過SWI指令所造成的一連串CPU Mode切換與Program Counter(PC)跳轉，大致上可以分解為以下數個步驟：</p><ol><li>切換CPU Operating mode到Supervisor(SVC)下，並將目前mode的CPSR保存到SPSR_svc，在這一步之後所有被操作的暫存器皆為svc專屬的bank(從datasheet的角度來講就是 <strong>_svc結尾的register</strong> )</li><li>將中斷結束後需要被執行的下一條指令(也就是PC - instructionLength)放入R14_svc(LR)</li><li>無論目前的CPU mode為何，一律切換CPU mode到ARM mode</li><li>將PC指定為中斷向量中軟體中斷的記憶體位置，依照慣例為0x08，緊接著重新填充管線</li><li>為了防止執行軟體中斷的同時硬體中斷也被觸發，CPSR I bit(IRQ disable bit)也會在指令的最後被set</li></ol><p>大致上SWI的工作流程我們可以從cycle table來看出個大概：<img src="https://i.imgur.com/WrTQhAi.png" alt="">Xn指的就是中斷向量的位置，值得一提的是即便最終管線有被重新填充，在指令的一開始我們還是有做instruction fetch，為了不要算錯cpu cycle，我們還是要針對PC + 2L所在的記憶體區段計算正確的N Cycle加到模擬器的cycle counter上</p><p>對了，後面會提的硬體中斷(IRQ)基本上也是類似的套路，直接將邏輯抽出來變成一個function是一個不錯的選擇</p><h3 id="軟體中斷的跳轉與實際運作">軟體中斷的跳轉與實際運作<a class="anchor" href="#軟體中斷的跳轉與實際運作">·</a></h3><p>講完了軟體中斷的進入，接下來是中間運作的機制:</p><ol><li>在CPU跳轉到0x08之後會看到一個branch指令，這次跳轉才會跳到BIOS中負責決定該去那一個handler的handler上(依照官方BIOS的設計，位置在0x140）</li><li>透過讀取lr的方式取得剛剛很可憐，被CPU當成塑膠的comment field，並透過位於0x1c8的swi_handler_table作跳轉</li><li>最後透過bx r12進入正確的handler</li></ol><p>要注意的一點是，以上只是針對任天堂官方BIOS做了一個粗略的解釋，我省略了不少內容，因為這一個部份的邏輯只要指令實作正確，基本上模擬器層不需要多加擔心，不過我強烈建議一定要去看一下這一部份的<a href="https://github.com/camthesaxman/gba_bios/blob/master/asm/bios.s">反組譯</a></p><h3 id="軟體中斷的結束與狀態恢復">軟體中斷的結束與狀態恢復<a class="anchor" href="#軟體中斷的結束與狀態恢復">·</a></h3><p>最後當中斷結束時，我們必須要還原到中斷前的狀態:</p><ol><li>GBA BIOS在執行軟體中斷時，會切換到system mode下(SVC-&gt;SYS)，在中斷結束時會切換回SVC</li><li>切換回SVC bank之後，從stack上取得中斷前的CPSR,放入SPSR</li><li>最後使用movs將LR寫回PC，mov指令當S bit set且dst為PC時會順帶將SPSR寫回CPSR，因此系統將會回復到中斷前的狀態，並重新填充管線</li></ol><p><img src="https://i.imgur.com/oZRyhLp.png" alt=""></p><p>我們可以發現GBA BIOS的確有遵照著ARM7TDMI Datasheet回復中斷前的狀態(見SWI Return Instruction一欄)</p><h3 id="小結">小結<a class="anchor" href="#小結">·</a></h3><p>中斷處理一直以來在模擬器實作上都是一個棘手的問題，因為其牽涉到CPU本身的指令實做與記憶體存取功能兩者是否正確(換言之，今天有bug發生你不太好釐清是誰有錯)</p><p>當CPU與週邊裝置開始連動時(LCD Joypad audio…)問題會變得更加複雜，因此強烈建議要做好測試，方便你後續釐清問題</p>]]></content>
      
      
      
        <tags>
            
            <tag> GBA </tag>
            
            <tag> emulator </tag>
            
            <tag> ARM </tag>
            
            <tag> system programming </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
