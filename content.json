{"meta":{"title":"黃爸爸狗園","subtitle":"","description":"","author":"0rzgg","url":"https://GGORZ10227216.github.io","root":"/"},"pages":[],"posts":[{"title":"Matrix calculation rules","slug":"basic-matrix-rule","date":"2022-08-03T13:21:09.000Z","updated":"2022-08-03T15:24:51.807Z","comments":true,"path":"2022/08/03/basic-matrix-rule/","link":"","permalink":"https://ggorz10227216.github.io/2022/08/03/basic-matrix-rule/","excerpt":"image alt The algebra of matrix follows some rules for addition and multiplication. Let us consider A, B and C are three different square matrices. A’ is the transpose and A-1 is the inverse of A. I is the identity matrix and c is a real number.","text":"image alt The algebra of matrix follows some rules for addition and multiplication. Let us consider A, B and C are three different square matrices. A’ is the transpose and A-1 is the inverse of A. I is the identity matrix and c is a real number. 神偷小吉從網路上偷來的線性代數小抄 Now as per the rules of laws of matrices: Also, see here rules for transposition of matrices: The inverse rules of matrices are as follows: prove:","categories":[],"tags":[{"name":"linear Algebra","slug":"linear-Algebra","permalink":"https://ggorz10227216.github.io/tags/linear-Algebra/"},{"name":"math","slug":"math","permalink":"https://ggorz10227216.github.io/tags/math/"}]},{"title":"Vector space","slug":"vector-space","date":"2022-08-03T09:27:02.000Z","updated":"2022-08-03T14:54:25.272Z","comments":true,"path":"2022/08/03/vector-space/","link":"","permalink":"https://ggorz10227216.github.io/2022/08/03/vector-space/","excerpt":"image alt 有關於向量空間的一些筆記，放在這裡以備不時之需","text":"image alt 有關於向量空間的一些筆記，放在這裡以備不時之需 Vector space &amp; subspaces = The set of all n-dimensional vectors. A subspace in the vector space must satisfies: If , in , is in If is in , is in = The set all combinations of &amp; Does equal to ? 我們可以試著證明看看是否還滿足封閉性 Column space &amp; Null space A is a matrix There are two important subspaces of A: Column space which is in any in Null space which is in We said that is solvable if and only if b can be expressed as combination of columns of A 換句話說，b要落在(的column space)中 就是vectors in Nullspace of () The set of all solutions to We know that is a subspace because: Let's suppose , are two vector in , that is has infinite solutions iff in other words, has exactly one sol. if Are all (which b is not zero)'s solution a subspace? NO If the solution set of has not path through the origin, that means we can combine two solutions of , then generate a new vector which is not in the solution set of Reduced row echelon form Is there a systematic way that can help us to find ? Yes. Suppose: Reduce A by Gauss Elimination，then get the (upper triangular form) matirx We notice that and are 1，which are pivot variables Let's analyse by formula's perspective: Let's say and are free variables , So the pivot variable are: , Finally, we can get the Complete solution Let's say that Complete solution is linear combination of Special solution, which is: = span of columns of Number of special sol. = number of free variable We know how to find N(A) now, but can we do it faster? Reduce row Echelon form Recall matrix, we'll keep reduce it by Jordan Elimination, finally get the matrix: Follow the step below to get N from R: we know the free variables are and , so fill the N like this(put the matrix into row 2 and row 4 of ): 2.Multiply remaining elements in by -1, then put them in N = #pivot of A #free variable = n - General solutions Suppose Ax = b, let's say x is General solution, which means: means complete homogeneous solution to is solution to which all free variables are 0 So, 這就代表只要存在，就一定會有解 如果存在，則有機會無限多解 如何檢驗? r = n r &lt; n r = m 1. 3. r &lt; m 2. 4. 的維度與相同，且也與未知數個數相同(無free variable) 唯一解， 的維度小於，且沒有free variable Full column rank 無解或者唯一解 的維度與相同，有free variable Full row rank 不僅存在，連也存在 無限多解 的維度小於，有free variable 無解或者無限多解 Independence, basis and dimension v1, v2, ..., vn are independent if only the trivial combination gives zero vector. otherwise, they are dependent. How to find the independent vectors in a span? Reduce the matrix to ，the column vector which has pivot is independent vector. We can also say that, a matrix is linear independet if full column rank A basis of a subspace is a set of vecotr v1, ..., vn are independent Dimension dim V = number of basis vecotrs in V conclusion The columns of are independent () rank = n(no free variable) 也就是說A中的向量剛剛好就是basis中的向量 , , , Column space Notation is In space The set of all combination of columns of Null space Notation is In space The set of solutions to Row space Notation is In space The set of all combination of rows of Left Nullspace Notation is In space The set of solutions of The reason why we call it \"Left\": , , 乘在A的左邊，使其為零，因此得名 Finding basis of these four space The basis of Pivot cols of The basis of Columns of the nullspace matrix = # free variables = The basis of Pivot rows of Notice that but The basis of There is a matrix call that can reduce to Rows of generating zero rows in are basis of 上述的內容即為The rank theory The invertible theorem is matrix(square) columns of form basis of columns of are independent 1, 2指的是沒有free variable，自然是唯一解 或從空間的角度來看，只要能夠在n為空間中提供n個pivot，那麼組成任意向量即可行 這一點與3,4,5,6,7說的是一樣的事情 應該說是，這7點其實都在講差不多的事情","categories":[],"tags":[{"name":"linear Algebra","slug":"linear-Algebra","permalink":"https://ggorz10227216.github.io/tags/linear-Algebra/"},{"name":"math","slug":"math","permalink":"https://ggorz10227216.github.io/tags/math/"}]},{"title":"GBA圖形處理邏輯模擬 (一)","slug":"GBA圖形處理邏輯模擬-一","date":"2022-07-21T16:13:05.000Z","updated":"2022-07-21T16:28:53.352Z","comments":true,"path":"2022/07/22/GBA圖形處理邏輯模擬-一/","link":"","permalink":"https://ggorz10227216.github.io/2022/07/22/GBA%E5%9C%96%E5%BD%A2%E8%99%95%E7%90%86%E9%82%8F%E8%BC%AF%E6%A8%A1%E6%93%AC-%E4%B8%80/","excerpt":"cover GBA模擬器的開發之路，如果說CPU部分是思考\"我到底該怎麼做才對\"，那圖形的部分就會是\"我到底要怎麼做才會快\" 本系列文將會把重點聚焦在如何正確的實作一個GBA的圖形系統模擬函式庫，並提出一些手法來提升模擬的效率","text":"cover GBA模擬器的開發之路，如果說CPU部分是思考\"我到底該怎麼做才對\"，那圖形的部分就會是\"我到底要怎麼做才會快\" 本系列文將會把重點聚焦在如何正確的實作一個GBA的圖形系統模擬函式庫，並提出一些手法來提升模擬的效率 GBA圖形系統規格 相較於近代的主機都普遍配有GPU來負責圖形渲染工作，GBA也有一塊獨立於CPU的處理邏輯負責圖形工作，也就是PPU(Pixel Processing Unit) 我們可以先來看一下PPU主要提供那些圖形處理功能: 1. 輸出畫面為240*160 pixels 2. 色彩格式為RGB555 3. 具有以下兩種渲染模式: - Tile based: 基於利用尺寸為8*8的tile組合畫面，具有渲染速度快，還可以利用硬體仿射變換功能 - Bitmap based: 直接由CPU將圖形資料以Pixel為單位寫入VRAM，自由度較高但效率差，須妥善利用DMA來實作 4. 最大支援128個Sprites於螢幕上顯示 5. 支援數種圖形特效: - Rotation/Scaling - alpha blending - fade-in/out - mosaic - window 記憶體區段 PPU的工作記憶體位於0x0500'0000~0x07ff'ffff，不同的段落具有不同的用途，描述如下: memory map Palette memory: 0x0500'0000 ~ 0x0500'03ff 功用為調色盤，一分為二，前半段為背景專用，後半段為OBJ使用 各具有256色，皆為RGB555格式 Bus為16 bit Video RAM(VRAM): 0x0600'0000 ~ 0x0601'7fff 圖形系統的主記憶體，內容會根據繪圖模式有所不同，後面會詳述 Bus為16 bit OBJ Attributes(OAM): 0x0700'0000 ~ 0x0700'03ff 用於描述各Sprite的屬性，以及Sprite在作仿射變換時所使用的矩陣內容 Bus為32 bit 聰明的小吉們應該有注意到一件事，我們在上面提到的address為0x0500'0000~0x07ff'ffff 但是下面再說明功能的時候，描述的範圍只有一部分，那剩下沒有涵蓋到(途中的黑色部分)的部分到底有沒有用??? 這裡就必須要提及GBA系統的Undefined behavior，其中的Memory mirror章節有提到GBA硬體的Bus在面對這些奇怪的R/W時會有那些行為 具體模擬的細節我會在MMU相關的文章內作說明 開發環境 我們的目標是要設計一個負責繪製GBA遊戲畫面的library，而非完全地將邏輯內嵌至模擬器主程式內，所以為了讓我們可以在沒有模擬除了PPU以外的功能的狀態下也能夠對PPU進行debug，我們勢必要開發一個前端，去調用PPU library所開出的介面來產生畫面 重點來了，阿你就沒有模擬整個系統，PPU怎麼會知道要繪製什麼東西??? pic 而問題的答案也很簡單，找另外一個模擬器，直接去dump他的memory再寫進我們的PPU memory即可 有一個除錯器NO$GBA可以幫我們做到這件事情，我們在後續的開發流程也會持續的使用這個工具來協助我們釐清問題 模擬流程 上面的說明中我有特別提到PPU在GBA系統中扮演的角色類似於我們現代電腦系統的GPU，但是其工作原理其實與GPU差異很大 現在的GPU基本上擅長一次處理大量的頂點或貼圖資料，但GBA的繪製流程是以scanline為單位，一條一條畫，同時繪圖狀態會根據H-Blank與V-Blank作變化 因此，我們並不會直接就利用GPU來繪製我們模擬器的遊戲畫面，而是先行使用CPU在main memory上產生出pixel format為RGB555的frame buffer後，緊接著一次做完整個畫面的RGB555 to RGBA8888的轉換，最後一步才是透過ImGUI把buffer的內容轉成texture，交由GPU渲染。","categories":[],"tags":[{"name":"GBA","slug":"GBA","permalink":"https://ggorz10227216.github.io/tags/GBA/"},{"name":"emulator","slug":"emulator","permalink":"https://ggorz10227216.github.io/tags/emulator/"},{"name":"graphics","slug":"graphics","permalink":"https://ggorz10227216.github.io/tags/graphics/"}]},{"title":"GBA的軟體中斷與其相對應的處理","slug":"hardirq","date":"2022-07-19T10:35:23.000Z","updated":"2022-07-21T16:17:12.347Z","comments":true,"path":"2022/07/19/hardirq/","link":"","permalink":"https://ggorz10227216.github.io/2022/07/19/hardirq/","excerpt":"cover GBA所使用的CPU ARM7TDMI要觸發中斷基本上有硬體中斷與軟體中斷兩種手段，兩種中斷的運作機制部份相似但在關鍵部份還是有所差異，若要正確模擬GBA的中斷就必須要將這兩種中斷的運作機制都搞清楚才行 換句話說，關於GBA的中斷沒有打模糊仗的空間，該讀的Spec就是要讀，該想的問題就是要想 本文會先就軟體中斷的部份作解說，硬體中斷會在另外一篇文章作描述","text":"cover GBA所使用的CPU ARM7TDMI要觸發中斷基本上有硬體中斷與軟體中斷兩種手段，兩種中斷的運作機制部份相似但在關鍵部份還是有所差異，若要正確模擬GBA的中斷就必須要將這兩種中斷的運作機制都搞清楚才行 換句話說，關於GBA的中斷沒有打模糊仗的空間，該讀的Spec就是要讀，該想的問題就是要想 本文會先就軟體中斷的部份作解說，硬體中斷會在另外一篇文章作描述 軟體中斷(SWI) 軟體中斷，顧名思義就是透過軟體觸發的中斷，更精確的說法是透過SWI指令所造成的一連串CPU Mode切換與Program Counter(PC)跳轉，大致上可以分解為以下數個步驟： 1. 切換CPU Operating mode到Supervisor(SVC)下，並將目前mode的CPSR保存到SPSR_svc，在這一步之後所有被操作的暫存器皆為svc專屬的bank(從datasheet的角度來講就是 **_svc結尾的register** ) 2. 將中斷結束後需要被執行的下一條指令(也就是PC - instructionLength)放入R14_svc(LR) 3. 無論目前的CPU mode為何，一律切換CPU mode到ARM mode 4. 將PC指定為中斷向量中軟體中斷的記憶體位置，依照慣例為0x08，緊接著重新填充管線 5. 為了防止執行軟體中斷的同時硬體中斷也被觸發，CPSR I bit(IRQ disable bit)也會在指令的最後被set 大致上SWI的工作流程我們可以從cycle table來看出個大概： Xn指的就是中斷向量的位置，值得一提的是即便最終管線有被重新填充，在指令的一開始我們還是有做instruction fetch，為了不要算錯cpu cycle，我們還是要針對PC + 2L所在的記憶體區段計算正確的N Cycle加到模擬器的cycle counter上 對了，後面會提的硬體中斷(IRQ)基本上也是類似的套路，直接將邏輯抽出來變成一個function是一個不錯的選擇 軟體中斷的跳轉與實際運作 講完了軟體中斷的進入，接下來是中間運作的機制: 1. 在CPU跳轉到0x08之後會看到一個branch指令，這次跳轉才會跳到BIOS中負責決定該去那一個handler的handler上(依照官方BIOS的設計，位置在0x140） 2. 透過讀取lr的方式取得剛剛很可憐，被CPU當成塑膠的comment field，並透過位於0x1c8的swi_handler_table作跳轉 3. 最後透過bx r12進入正確的handler 要注意的一點是，以上只是針對任天堂官方BIOS做了一個粗略的解釋，我省略了不少內容，因為這一個部份的邏輯只要指令實作正確，基本上模擬器層不需要多加擔心，不過我強烈建議一定要去看一下這一部份的反組譯 軟體中斷的結束與狀態恢復 最後當中斷結束時，我們必須要還原到中斷前的狀態: 1. GBA BIOS在執行軟體中斷時，會切換到system mode下(SVC-&gt;SYS)，在中斷結束時會切換回SVC 2. 切換回SVC bank之後，從stack上取得中斷前的CPSR,放入SPSR 3. 最後使用movs將LR寫回PC，mov指令當S bit set且dst為PC時會順帶將SPSR寫回CPSR，因此系統將會回復到中斷前的狀態，並重新填充管線 我們可以發現GBA BIOS的確有遵照著ARM7TDMI Datasheet回復中斷前的狀態(見SWI Return Instruction一欄) 小結 中斷處理一直以來在模擬器實作上都是一個棘手的問題，因為其牽涉到CPU本身的指令實做與記憶體存取功能兩者是否正確(換言之，今天有bug發生你不太好釐清是誰有錯) 當CPU與週邊裝置開始連動時(LCD Joypad audio.....)問題會變得更加複雜，因此強烈建議要做好測試，方便你後續釐清問題","categories":[],"tags":[{"name":"GBA","slug":"GBA","permalink":"https://ggorz10227216.github.io/tags/GBA/"},{"name":"emulator","slug":"emulator","permalink":"https://ggorz10227216.github.io/tags/emulator/"},{"name":"ARM","slug":"ARM","permalink":"https://ggorz10227216.github.io/tags/ARM/"},{"name":"system programming","slug":"system-programming","permalink":"https://ggorz10227216.github.io/tags/system-programming/"}]}],"categories":[],"tags":[{"name":"linear Algebra","slug":"linear-Algebra","permalink":"https://ggorz10227216.github.io/tags/linear-Algebra/"},{"name":"math","slug":"math","permalink":"https://ggorz10227216.github.io/tags/math/"},{"name":"GBA","slug":"GBA","permalink":"https://ggorz10227216.github.io/tags/GBA/"},{"name":"emulator","slug":"emulator","permalink":"https://ggorz10227216.github.io/tags/emulator/"},{"name":"graphics","slug":"graphics","permalink":"https://ggorz10227216.github.io/tags/graphics/"},{"name":"ARM","slug":"ARM","permalink":"https://ggorz10227216.github.io/tags/ARM/"},{"name":"system programming","slug":"system-programming","permalink":"https://ggorz10227216.github.io/tags/system-programming/"}]}